# **数据结构--索引堆**

**何为索引堆？**

索引堆是对堆进行了优化。关于堆的介绍可以查看[数据结构--堆](https://www.yasinshaw.com/article/15)。



**优化了什么？**

在堆中，构建堆、插入、删除过程都需要大量的交换操作。在之前的实现中，进行交换操作是直接交换`datas`数组中两个元素。<font color='red'>而索引堆**交换的是这两个元素的索引，而不是直接交换元素**。</font>



**有什么好处？**

主要有两个好处：

1. 减小交换操作的消耗，尤其是对于元素交换需要很多资源的对象来说，比如大字符串。
2. 可以根据原位置找到元素，即便这个元素已经换了位置。



### **如何做到的？**

索引堆使用了一个新的`int`类型的数组，用于存放索引信息。部分代码如下：

```java
// 属性
T[] datas; // 存放数据的数组 datas[1..n]
int[] indexes; // 索引数组
```

这里这个`indexes`数组，存放的是什么信息呢？它是如何工作的呢？假如我们有这样一个最小堆：

用数组表示是：

> datas: [-, 1, 15, 20, 34, 7]

现在要维护最小堆的有序性，就需要交换`15`和`7`这两个元素。交换之后的元素数组是：

> datas: [-, 1, 7, 20, 34, 15]

而此时，我们再想找到原来在datas[2]位置的元素，已经找不到了。因为此时data[2]已经换成了`7`，而系统并没有记录`15`被换到了什么地方。

这个时候，想要得到i位置的元素，直接`datas[i]`就可以了。

### 使用索引堆

<font color='red'>元素比较的时候是datas的数据，而交换时候是indexes的数据(索引)，datas不做任何改动。</font>

使用索引堆后，初始化两个数组应该是这样的：

> - datas: [-, 1, 15, 20, 34, 7]
> - indexes: [-, 1, 2, 3, 4, 5]

这个时候，我们就交换`indexes`数组里面的索引`2`和`5`，而不操作`datas`数组。交换后两个数组是这个样子：

> - datas: [-, 1, 15, 20, 34, 7]
> - indexes: [-, 1, 5, 3, 4, 2]

这个时候，想要得到i位置的元素，就需要`datas[indexes[i]]`来获取。

**用图来理解：**

构建前：

![](<http://img.dongcoder.com/up/info/201807/20180719233859584351.png>)

构建后：

![](<http://img.dongcoder.com/up/info/201807/20180719233859880231.png>)





### 索引堆的优化               

前面的index heap 虽然解决了改变堆中元素，由于data位置是不改变的，所以可以通过 data[i] = newItem; 但是，改变index数组以维护队的性质这个操作就无法通过一步实现了，此时，需要先遍历indexes数组，时间复杂度是O(N)，再调整的时间复杂度是O(logN),所以T(N) = O(N0+O(logN)。

比如，我们想要改变所以位置4的data，更改后要维护这个堆，这个堆中存储的元素是上一行的索引，所以要在indexes数组中找到4所在位置，需要遍历indexes数组，找到是第9个位置，然后对滴9个位置调整，如果，我们在对这个类中添加一个reverse属性，关系如下：

![](<http://img.dongcoder.com/up/info/201807/20180719233900125332.png>)



**rev与index的关系：**



![](<http://img.dongcoder.com/up/info/201807/20180719233900294267.png>)

