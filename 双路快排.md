# 快速排序

### 普通的快速排序

首先选择数组中的一个元素，比如用 l 索引指向最左边的元素v，逐渐遍历数组所有位于l左边的元素，在遍历的过程中，我们将逐渐整理出小于v的元素和大于v的元素，当然我们继续用一个索引j来记录小于v和大于v的分界点，然后我们当前访问的元素索引为i。



快速排序虽然高效，但并不稳定，当数组中存在大量重复元素时，比如举个例子，我用模板测试归并排序和快速排序的时间，设置一个1000000的数组，数组元素在0-10之间随机取值，那么用归并需要花费0.290727s而快排需要花费171.151s，对，你没有看错。当快速排序最优的时候是o（nlgn），而此时显然退化到了o（n^2）的级别。这是为什么？

还记得上面我写的快排的子过程么，考虑到了e>v,e<v，而e=v的情况没有考虑对吧。看了代码理解了的同学应该清楚，其实我是把等于v这种情况包含进了大于v的情况里面了，那么会出现什么问题？ <font color='tomato'>不管是当条件是大于等于还是小于等于v，当数组中重复元素非常多的时候，等于v的元素太多，那么就将数组分成了极度不平衡的两个部分，因为等于v的部分总是集中在数组的某一边。</font>



### 双路快排

#### 思路：把数组分为arr[l+1...i)<=v和arr（j...r] >=v两部分。(把==v的元素分散到了左右两部分)

在sort函数中进行partition函数操作，返回pivot。后进行sort(arr,l,p-1)和sort(arr,p+1,r)的递归调用。（关键是partition函数的构造。）

**partition函数的构造**

1，先随机选取一个index，并将其对应的元素于arr[l]进行交换，使其成为v

2，i的初始值从l+1开始，j从r开始。目的是：开始时arr[l+1...i)和arr（j...r]数组为空。

3，进行while（true）循环且其中有两个子while循环：只要arr[i]<v,循环继续，i++;只要arr[j]>v，循环继续，j--。

(**为什么不挂等号？**当 i 和 j 所指向的元素都==v时，两个元素仍然需要交换位置，这样一来不会有大量==v的元素集中在一边。而使得算法时间复杂度降低。)

当不满足两个子while循环的条件时，（意味着a[i]>=v;a[j]<=v）需要交换i,j对应两个元素

如果 i>j 则跳出循环。

4，当全部循环结束后，由于i >j ，j对应元素<v,所以a[l]与a[j]交换

5，返回j（pivot所在的index）

```java
public class QuickSort2Way{
    //定义交换元素的方法
    private static void swap(arr[i],arr[j]){
        Object tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    //双路快速排序的partition
    //将数组分为>=v和<=v两部分并返回pivot所对应的index，
    private static int partion(Comparable[] arr,int l,int r){
        //随机在arr[l..r]的范围中，选择一个index对应的数值作为标定点pivot，避免arr[l]就是最小值
        swap(arr[l],arr[(int)(Math.random()*(r-l+1)+l)]);
        //把v设置为最左端的元素
        Comparable v = arr[l];
        
        //为了把数组分为arr[l+1...i)<=v和arr(j...r]>=v两部分
        int i = l+1,j = r;
        while(true){
            //这里的边界不能挂等号
            while(i<=r && arr[i] < arr[l+1])
                i++;  
            while(j>= l+1 && arr[j] > arr[j-1])
                j--;
            if(i>j)  //如果i超过了j的循环结束
                break; 
            swap(arr[i],arr[j]); // i，j都不移动了，证明a[i]>=v;a[j]<=v，就交换i,j对应两个元素
            i++;                 //交换后，i，j继续移动
            j--;
        }
        swap(arr[l],arr[j]);     //全部循环结束后，由于j已经小于i，j对应的是<v的元素，因此
        return j;
    }
    //递归使用快速排序，对arr[l...r]的范围进行排序
    private static void sort(Comparable[] arr,int l,int r){
        //传入数组，左边界和右边界
        int p = partition(arr,l,r); //p为pivot左边<=v;右边>=v
        sort(arr,l,p-1); //继续递归调用直到将数组分为一个元素，则返回它自身
        sort(arr,p+1,r);
    }
    public static void sort(Comparable[] arr){
        int n = arr.length;
        sort(arr,o,n-1);
    }
}
```



### 三路快排

#### 思路：把数组分为arr[l+1...lt]<v; arr[lt+1...i) == v; arr[gt...r]>v三部分。

此时不需要partition函数。直接在sort函数中分情况讨论，后进行递归调用。

1，先随机选取一个index，并将其对应的元素于arr[l]进行交换，使其成为v

2，由于是闭区间，因此设 lt 初始值为l；gt的初始值为r+1。即开始时arr[l+1...lt]和arr[gt...r]中不存在元素。

3，开始while循环,循环条件是 i<gt 。==v的数组范围没有和>v的数组范围对撞。

4，在while循环中，如果arr[i]<v，则与（arr[lt+1...i)==v数组左边界的）arr[lt+1]进行交换，由于换过来的元素等于v，因此i直接向前移动；（且arr[l+1...lt] <v 的数组范围扩容）lt+1对应的是 <v 的元素因此lt需要向前移动一个位置。如果arr[i]>v, 则直接与arr[gt-1]进行交换，此时gt-1对应的是 >v 的元素，因此gt需要向前移动一位，<font color='tomato'>**但是由于交换过来的元素是未知的所以 i 不能向前移动**</font>。如果arr[i] == v 则 i 直接向前移动。

**因为i是紧挨左边界的所以左边界交换来的元素已知，而右边界交换来的元素未知。**

5,最后进行arr[l]与(arr[l+1...lt]<v的右边界)arr[lt]的交换。

6，最后进行sort(arr, l, lt-1)和sort(arr, gt, r)的递归调用。

```java

```



### LeetCode真题---75.Sort Colors

75. Sort Colors

Medium

Given an array with *n* objects colored red, white or blue, sort them **in-place** so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

**Note:** You are not suppose to use the library's sort function for this problem.

**Example:**

```
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

本题：只有三个元素0，1，2三个元素。适合使用三路快排。arr[i] ==0排到左边，arr[i]==2排到右边，最后中间剩下的是1

```java
class Solution {
    public void sortColors(int[] nums) {
       int l = -1, r = nums.length , i = 0;
        while (i < r) {
            if (nums[i] == 0) {
                int tmp = nums[i] ;
                nums[i] = nums[l+1];
                nums[l+1] = tmp;
                l++;
            }
            if (nums[i] == 2) {
            	int tmp = nums[i] ;
                nums[i] = nums[r-1];
                nums[r-1] = tmp;
                r--;
                i--; //由与交换过来的元素未知也许还是2，所以i还要检查一遍
            }
            i++;
        }
}
```

